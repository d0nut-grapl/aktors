#![feature(await_macro, async_await)]
#[macro_use]
extern crate futures;
#[macro_use]
extern crate tokio;
extern crate tokio_async_await;

use futures::{Future, Poll, Async};
use futures::lazy;
use futures::sync::mpsc::{Receiver, Sender, channel};
use futures::stream::Stream;
use futures::sink::Sink;
use tokio_async_await::compat::backward;
use tokio::runtime::Runtime;

use crate::tests;

struct PrintLogger {}

impl PrintLogger {
    pub async fn info(&mut self, data: String) -> Result<(), ()> {
        println!("{}", data);

        Ok(())
    }
    pub async fn error(&mut self, data: String) -> Result<(), ()> {
        println!("{}", data);

        Ok(())
    }
}
// Code from this point forward is generated by the derive_actor macro above
// Union type representing functions and their arguments of hte underlying PrintLogger
enum PrintLoggerMessage {
    Info { data: String },
    Error { data: String },
}

struct PrintLoggerActorRouter {
    receiver: Receiver<PrintLoggerMessage>,
    id: String,
    actor_impl: PrintLogger
}

// The actual Actor, which will send messages to the underlying PrintLogger
struct PrintLoggerActor {
    sender: Sender<PrintLoggerMessage>,
}
// This impl will provide an identical API to the impl for the underlying PrintLogger, as well as a
// 'new' function, which will take an execution handle and an already constructed PrintLogger
impl PrintLoggerActor {
    pub fn new(actor_impl: PrintLogger) -> PrintLoggerActor {
        let (sender, receiver) = channel(0);
        let id = "random string".to_owned();

        tokio::spawn(PrintLoggerActorRouter {
            receiver,
            id,
            actor_impl
        });

        PrintLoggerActor {
            sender
        }
    }

    pub async fn info(&mut self, data: String) {
        let msg = PrintLoggerMessage::Info { data };
        await!(self.sender.clone().send(msg));
    }

    pub async fn error(&mut self, data: String) {
        let msg = PrintLoggerMessage::Error { data };
        await!(self.sender.clone().send(msg));
    }
}

impl Future for PrintLoggerActorRouter {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self.receiver.poll() {
            Ok(Async::Ready(Some(msg))) => {
                self.actor_impl.route_message(msg);

                Ok(Async::NotReady)
            },
            Ok(Async::Ready(None)) => {
                self.receiver.close();

                Ok(Async::Ready(())) // we're done; disconnect
            },
            _ => {
                Ok(Async::NotReady)
            }
        }
    }
}
// We lastly generate the route_message function, which deconstructs our message and routes it to
// the underlying function
impl PrintLogger {
    pub async fn route_message(&mut self, msg: PrintLoggerMessage) {
        match msg {
            PrintLoggerMessage::Info { data } => await!(self.info(data)),
            PrintLoggerMessage::Error { data } => await!(self.error(data)),
        };
    }
}

