#[macro_use]
extern crate futures;
#[macro_use]
extern crate tokio;

use futures::{Future, Poll, Async, task};
use futures::lazy;
use futures::sync::mpsc::{Receiver, Sender, channel};
use futures::stream::Stream;
use futures::sink::Sink;
use tokio::runtime::Runtime;
use futures::task::Task;

mod tests;

#[derive(Default)]
struct CountLogger {
    count: u32
}

impl CountLogger {
    pub fn count(&mut self) {
        self.count += 1;

        println!("[COUNT] - {}", self.count);
    }
}

enum CountLoggerMessage {
    Count { }
}

struct CountLoggerActorRouter {
    receiver: Receiver<CountLoggerMessage>,
    id: String,
    actor_impl: CountLogger
}

#[derive(Clone)]
struct CountLoggerActor {
    sender: Sender<CountLoggerMessage>,
}

impl CountLoggerActor {
    pub fn new(actor_impl: CountLogger) -> Self {
        let (sender, receiver) = channel(0);
        let id = "random string".to_owned();

        tokio::spawn(CountLoggerActorRouter {
            receiver,
            id,
            actor_impl
        });

        CountLoggerActor {
            sender
        }
    }

    pub fn count(&self) {
        let msg = CountLoggerMessage::Count {};

        tokio::spawn(self.sender.clone().send(msg).map(|_|()).map_err(|_|()));
    }

}

impl Future for CountLoggerActorRouter {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self.receiver.poll() {
            Ok(Async::Ready(Some(msg))) => {
                task::current().notify(); // we should poll on receiver again

                self.actor_impl.route_message(msg);
                Ok(Async::NotReady)
            },
            Ok(Async::Ready(None)) => {
                self.receiver.close();

                Ok(Async::Ready(())) // we're done; disconnect
            },
            _ => {
                Ok(Async::NotReady)
            }
        }
    }
}

impl CountLogger {
    pub fn route_message(&mut self, msg: CountLoggerMessage) {
        match msg {
            CountLoggerMessage::Count { } => self.count(),
        };
    }
}

// ------------------------------------
// BEGIN PRINT LOGGER SECTION
// ------------------------------------

struct PrintLogger {}

impl PrintLogger {
    pub fn info(&mut self, data: String, counter: CountLoggerActor) {
        println!("[INFO] - {}", data);

        counter.count();
    }
    pub fn error(&mut self, data: String, counter: CountLoggerActor) {
        println!("[ERROR] - {}", data);

        counter.count();
    }
}
// Code from this point forward is generated by the derive_actor macro above
// Union type representing functions and their arguments of hte underlying PrintLogger
enum PrintLoggerMessage {
    Info { data: String, counter: CountLoggerActor },
    Error { data: String, counter: CountLoggerActor },
}

struct PrintLoggerActorRouter {
    receiver: Receiver<PrintLoggerMessage>,
    id: String,
    actor_impl: PrintLogger
}

// The actual Actor, which will send messages to the underlying PrintLogger
#[derive(Clone)]
struct PrintLoggerActor {
    sender: Sender<PrintLoggerMessage>,
}
// This impl will provide an identical API to the impl for the underlying PrintLogger, as well as a
// 'new' function, which will take an execution handle and an already constructed PrintLogger
impl PrintLoggerActor {
    pub fn new(actor_impl: PrintLogger) -> Self {
        let (sender, receiver) = channel(0);
        let id = "random string".to_owned();

        tokio::spawn(PrintLoggerActorRouter {
            receiver,
            id,
            actor_impl
        });

        PrintLoggerActor {
            sender
        }
    }

    pub fn info(&self, data: String, counter: CountLoggerActor) {
        let msg = PrintLoggerMessage::Info { data, counter };

        tokio::spawn(self.sender.clone().send(msg).map(|_|()).map_err(|_|()));
    }

    pub fn error(&self, data: String, counter: CountLoggerActor) {
        let msg = PrintLoggerMessage::Error { data, counter };

        tokio::spawn(self.sender.clone().send(msg).map(|_|()).map_err(|_|()));
    }
}

impl Future for PrintLoggerActorRouter {
    type Item = ();
    type Error = ();

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self.receiver.poll() {
            Ok(Async::Ready(Some(msg))) => {
                task::current().notify(); // we should poll on receiver again

                self.actor_impl.route_message(msg);

                Ok(Async::NotReady)
            },
            Ok(Async::Ready(None)) => {
                self.receiver.close();

                Ok(Async::Ready(())) // we're done; disconnect
            },
            _ => {
                Ok(Async::NotReady)
            }
        }
    }
}
// We lastly generate the route_message function, which deconstructs our message and routes it to
// the underlying function
impl PrintLogger {
    pub fn route_message(&mut self, msg: PrintLoggerMessage) {
        match msg {
            PrintLoggerMessage::Info { data, counter } => self.info(data, counter),
            PrintLoggerMessage::Error { data, counter } => self.error(data, counter),
        };
    }
}

