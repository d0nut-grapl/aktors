struct PrintLogger {

}
#[derive_aktor]
impl PrintLogger {
    pub fn info(data: String) {
        println!("{:?}", data);
    }
    pub fn error(data: String) {
        println!("{:?}", data);
    }
}
// Code from this point forward is generated by the derive_actor macro above
// Union type representing functions and their arguments of hte underlying PrintLogger
enum PrintLoggerMessage {
Info {
data: String
},
Error {
data: String
}
}
// The actual Actor, which will send messages to the underlying PrintLogger
struct PrintLoggerActor {
sender: Sender<PrintLoggerMessage>,
receiver: Receiver<PrintLoggerMessage>,
id: String
}
// This impl will provide an identical API to the impl for the underlying PrintLogger, as well as a
// 'new' function, which will take an execution handle and an already constructed PrintLogger
impl PrintLoggerActor {
pub fn new(handle: Handle, actor: PrintLogger) -> PrintLoggerActor {
let (sender, receiver) = channel::new();
let id = "random string".to_owned();
let recvr = receiver.clone();

handle.spawn(futures::lazy(move || {
loop_fn(0, move |_| match recvr.try_recv() {
Ok(msg) => {
actor.route_message(msg);
Ok::<_, _>(Loop::Continue(0))
}
Err(TryRecvError::Disconnected) => Ok::<_, _>(Loop::Break(())),
Err(TryRecvError::Empty) => Ok::<_, _>(Loop::Continue(0)),
})
}));
PrintLoggerActor {
sender: sender,
receiver: receiver,
id: id
}
}

pub fn info(data: String) {
let msg = PrintLoggerMessage::Info { data: data };
self.sender.send(msg);
}
pub fn error(data: String) {
let msg = PrintLoggerMessage::Error { data: data };
self.sender.send(msg);
}
}
// We lastly generate the route_message function, which deconstructs our message and routes it to
// the underlying function
impl PrintLogger {
pub fn route_message(&mut self, msg: PrintLoggerMessage) {
match msg {
PrintLoggerMessage::Info(data) => self.info(data),
PrintLoggerMessage::Error(data) => self.error(data),
}
}
}
fn main() {
let system = ThreadPoolExecutor::with_thread_count(2).unwrap();
let logger = PrintLogger{};
let log_actor = PrintLoggerActor::new(system.handle(), logger);
// These two functions return immediately
// None of our written code had to use threads or fibers or futures or anything,
// concurrency for free.

log_actor.info("info log");
log_actor.error("error!!");
system.run();
}